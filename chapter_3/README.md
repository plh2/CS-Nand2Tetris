# 第三章 时序逻辑

前面实现的布尔芯片和算数芯片都是**组合芯片**,组合芯片只能实现那些**输出结果仅依赖于其输入变量的排列组合**的函数,他们不能维护自身状态,但是计算机不仅仅只是计算数据,他还要储存数据,因此这些芯片必须配备记忆单元,这些记忆单元由**时序芯片**组成.

记忆单元是复杂的过程,包括同步,时钟和反馈回路.其中大部分能被封装到称之为`触发器`的底层`时序门`中,

## 背景知识

**时钟(Clock)**,在大多数计算机里面,时间的流逝是主时钟来表示的,它提供连续的交变信号序列,其精确的硬件实现通常基于振荡器,其在两个信号值 0-1,称之为高低电平交替变化,

**触发器(Flip-Flops)**,计算机里面最基本的时序单元是称为**触发器**设备,它有几个种变体, 触发器在这里的主要目的是记住上一秒的输入.

由此可见,这种基本行为是维持所有计算机硬件维持自身状态的基础,从二进制到寄存器以及任意大的随机存取单元(RAM)皆如此.

**寄存器(Registers)**,具有记忆功能的设备,他能存储或者记忆某一时刻的值,实现经典的存储行为,同时,DFF 只能输出它前一刻钟输入的值,,也就是 out(t)=out(t-1)

**多路转换器**,这个多路转换器的选择位,是可以成为整个寄存器芯片的加载位;如果希望寄存器开始存储一个新值,可以把这个值于 in 输入口,然后 load 设置成 1;如果希望寄存器一直存储它的内部值直到新的指令到来,可以将 load 位设为 0.

实现了 1 位比特位的基本机制,就可以轻松构建任意宽度的寄存器.,这个可以通过由多个 1 比特位的寄存器构成阵列来实现.以构建可保存多比特位值的寄存器,比如 16/32/64 位

**内存**,一旦具备表示字的基本能力,就能构建任意长度的存储块,RAM(random access memory)由此而来.在 RAM 单元实现随机被访问被选择的字而不会收到访问顺序,也就是我们访问内存中任何字,无论物理位置在哪,都能以相等的速度被直接访问.

**计数器**,计数器是一种时序芯片,它的状态是整数,每经过一个时间周期,该整数就增加一个单位,执行函数 `out(t)=out(t-1)+c`.计数器在数字系统中担任很重要的绝色

### DFF 触发器

最基本的时序设备就是 DFF 门,他能输出它前一刻钟输入的值,`out(t)=out(t-1)`,换句话说 DFF 就是简单的将前一个时间的周期的输入值作为当前周期的输出.

### 寄存器 Register

寄存器是具有记忆功能的设备,一个比特寄存器可以称为比特(Bit)或者二进制单元.用来存储信息的一个比特位(0/1),芯片的接口,比特和寄存器芯片的读写行为几乎一致

### PC(计数器)

虽然计数器是独立的抽象,但是可以通过它的一些应用来描述,比如考虑下一个,指令地址计数器.它的内容是计算器下一个时钟要读取和执行的指令,程序计数器是用于存放下一条指令所在单元的地址的地方。程序计数器是计算机处理器中的寄存器，它包含当前正在执行的指令的地址（位置）.当每个指令被获取，程序计数器的存储地址加一。在每个指令被获取之后，程序计数器指向顺序中的下一个指令。当计算机重启或复位时，程序计数器通常恢复到零。

但是，当遇到转移指令如 JMP（跳转、外语全称：JUMP）指令时，后继指令的地址（即 PC 的内容）必须从指令寄存器中的地址字段取得。在这种情况下，下一条从内存取出的指令将由转移指令来规定，而不像通常一样按顺序来取得。因此程序计数器的结构应当是具有寄存信息和计数两种功能的结构。

PC 计数器的本质是寄存器.

**冯 ·诺伊曼计算机体系结构**的主要内容之一就是**程序预存储，计算机自动执行!** 处理器要执行的程序（指令序列）都是以二进制代码序列方式预存储在计算机的存储器中，处理器将这些代码逐条地取到处理器中再译码、执行，以完成整个程序的执行。为了保证程序能够连续地执行下去，CPU 必须具有某些手段来确定下一条取指指令的地址。程序计数器（PC ）正是起到这种作用，所以通常又称之为‘指令计数器’。

```dhl
CHIP PC {
    IN in[16],load,inc,reset;
    OUT out[16];

    PARTS:
    // Put your code here:
    // inc
    Inc16(in=outhistory, out=increaseIn);   // 自增,意思就是指向下一个指令
    Mux16(a=outhistory, b=increaseIn, sel=inc, out=incout);
    // load
    Mux16(a=incout, b=in, sel=load, out=outload); // 是否加载某个指令,当遇到JMP之类的跳转指令的时候, PC程序计数器跳转到另一个地址.
    // reset
    Mux16(a=outload, b[0..15]=false, sel=reset, out=outreset);  // 关机的时候就重置指令位置

    Register(in=outreset, load=true, out=out,out=outhistory); // 寄存器将上述 经历过if/else逻辑后的值重新读取
}
```

### Bit

一个具备读写功能的 bit 单位.如何实现?

Mux 用于
根据 load=2 判断这是写入行为, 则有 out2 为 in 值,
根据 load=1 判断这是读取行为, 则有 out1 为 in 值,
DFF 用于存储并输出
DFF in 值为刚才 Mux+laod 经过一层判断,输出的 out2 值

```hdl
CHIP Bit {
  IN in, load;
  OUT out;

  PARTS:
  Mux(a=out1, b=in, out=out2)
  DFF(in=out2, out=out1, out=out)
}
```

### RAM

可进行直接访问的记忆单元称之为 RAM,是由 n 个 w 为寄存器组成的阵列,配有直接访问电路.寄存器个数(n)和每个寄存器的宽度 w,分别称之为内存的 size 和 width,我们将可以开始构建这一个存储体系,都是 16 芯片位宽,但是大小不同分为`RAM8`,`RAM64`,`RAM512`,`RAM4k`,`RAM16k`

### DFF 门

#### 1) 初始稳定结构

输入 1 1

输出 ? ?

![image](./01.png)

#### 2) 改动后的结构返回的是上一次的输入

输入 0 1

输出 1 0

![image](./02.png)

#### 3) 稳定

输入 1 1

输出 1 0

![image](./03.png)

#### 4) 稳定

输入 1 0

输出 0 1

![image](./04.png)

#### 5) 稳定

输入 1 1

输出 0 1

![image](./05.png)
